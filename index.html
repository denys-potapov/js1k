<!doctype html>
<meta charset=utf-8>
<body id=b>
<canvas id=a width=640 height=640>
<script>
d = document;
g = a.getContext('webgl');

/*

JS1K's shim gives the following vars for free:
- a: canvas element
- b: body
- d: document
- g: webgl context for the canvas.

*/

// GUI: canvas
a.style="width:100%;height:100vh";

// Canvas methods hashing:
// This loop creates tiny shortcuts for all the webgl context's methods/constants we need:
// createProgram => cP
// shaderSource => sS
// createShader => cS
// compileShader => ce
// attachShader => aS
// linkProgram => lo
// useProgram => ug
// bindBuffer => bf
// createBuffer => cB
// enableVertexAttribArray => eV
// vertexAttribPointer => vA
// bufferData => bD
// getUniformLocation => gf
// drawArrays => dr
// NO_ERROR => NO (value = 0)
// FRAGMENT_SHADER => FN (value: 35632)
// ELEMENT_ARRAY_BUFFER_BINDING => ET (value: 34965)
// We need to redefine the webgl context because adding the textarea in the DOM rewrote the canvas "a".
for(i in g=a.getContext("webgl")){
  g[i[0]+i[6]]=g[i];
}

// Mouse coordinates
iMouse=[0,0,0,0];
// Use the WebGL context's scope for all the following code
with(g){
  // Define a new program
  // p=createProgram();
  p=cP();
  
  // Basic vertex shader
  // shaderSource(s=createShader(VERTEX_SHADER),"attribute vec2 p;void main(){gl_Position=vec4(p,0,1);}");
  sS(s=cS(35633),"attribute vec2 p;void main(){gl_Position=vec4(p,0,1);}");
  
  // Compile and attach it to the program
  // compileShader(s);
  ce(s);
  
  //attachShader(p,s);
  aS(p,s);
  
  // Main program
  // shaderSource(s=createShader(FRAGMENT_SHADER),'precision mediump float;uniform float iGlobalTime,iFrame,iDate,iTimeDelta;varying lowp vec4 fragCoord;uniform vec2 iResolution;uniform vec4 iMouse;' +c.value+'void main(){mainImage(gl_FragColor,gl_FragCoord.xy);gl_FragColor.w=1.;}');
  sS(s=cS(FN),`precision mediump float;
uniform float iGlobalTime,iFrame,iDate,iTimeDelta;
varying lowp vec4 fragCoord;
uniform vec2 iResolution;
uniform vec4 iMouse;

#define iterations 17
#define formuparam 0.53

#define volsteps 20
#define stepsize 0.1

#define zoom   0.800
#define tile   0.850
#define speed  0.010 

#define brightness 0.0015
#define darkmatter 0.300
#define distfading 0.730
#define saturation 0.850


void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
  //get coords and direction
  vec2 uv=fragCoord.xy/iResolution.xy-.5;
  uv.y*=iResolution.y/iResolution.x;
  vec3 dir=vec3(uv*zoom,1.);
  float time=iGlobalTime*speed+.25;

  //mouse rotation
  float a1=.5+iMouse.x/iResolution.x*2.;
  float a2=.8+iMouse.y/iResolution.y*2.;
  mat2 rot1=mat2(cos(a1),sin(a1),-sin(a1),cos(a1));
  mat2 rot2=mat2(cos(a2),sin(a2),-sin(a2),cos(a2));
  dir.xz*=rot1;
  dir.xy*=rot2;
  vec3 from=vec3(1.,.5,0.5);
  from+=vec3(time*2.,time,-2.);
  from.xz*=rot1;
  from.xy*=rot2;
  
  //volumetric rendering
  float s=0.1,fade=1.;
  vec3 v=vec3(0.);
  for (int r=0; r<volsteps; r++) {
    vec3 p=from+s*dir*.5;
    p = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold
    float pa,a=pa=0.;
    for (int i=0; i<iterations; i++) { 
      p=abs(p)/dot(p,p)-formuparam; // the magic formula
      a+=abs(length(p)-pa); // absolute sum of average change
      pa=length(p);
    }
    float dm=max(0.,darkmatter-a*a*.001); //dark matter
    a*=a*a; // add contrast
    if (r>6) fade*=1.-dm; // dark matter, don't render near
    //v+=vec3(dm,dm*.5,0.);
    v+=fade;
    v+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance
    fade*=distfading; // distance fading
    s+=stepsize;
  }
  v=mix(vec3(length(v)),v,saturation); //color adjust
  fragColor = vec4(v*.01,1.); 
  
}


void main(){mainImage(gl_FragColor,gl_FragCoord.xy);gl_FragColor.w=1.;}`);
  
  // Compile and attach it to the program
  // compileShader(s);
  ce(s);
  
  // DEBUGS
  if (!g.getShaderParameter(s, g.COMPILE_STATUS)) {
    g.getShaderInfoLog(s).trim().split("\n").forEach(ss =>
    console.warn("[shader] " + ss))
    throw new Error("Error while compiling shader")
  };

  // attachShader(p,s);
  aS(p,s);
  
  // Link and start the program
  //linkProgram(P);
  lo(p);
  
  //useProgram(p);
  ug(p);
  
  // Define a big triangle the canvas, containing the viewport
  // bindBuffer(g=ARRAY_BUFFER, createBuffer());
  bf(g=34962,cB());
  
  // enableVertexAttribArray(0);
  eV(0);
  
  // vertexAttribPointer(0, 2, BYTE, 0, 0, 0);
  vA(0,2,5120,0,0,0);
  
  // bufferData(g,new Int8Array([-3, 1, 1, -3, 1, 1]), STATIC_DRAW);
  bD(g,new Int8Array([-3,1,1,-3,1,1]),35044);
  
  // Reset frame counter
  iFrame=0;
  // Reset playback time (in seconds)
  o=0;
  
  // Date (in seconds)
  f=new Date()/1e3
  
  // Time delta (in seconds)
  d=0;
  
  // Main loop
  (L=function(){
    
    // Time delta since last frame (in seconds)
    d=(new Date()/1e3-f);
    // Date (in seconds)
    f=new Date()/1e3;
    
    // uniform1f(getUniformLocation(p, "iTimeDelta"), d);
    uniform1f(gf(p,"iTimeDelta"),d);
    
    // Current playback time (in seconds)
    // uniform1f(getUniformLocation(p,"iGlobalTime"), o += d);
    uniform1f(gf(p,"iGlobalTime"),o+=d);
    
    // Current playback frame
    // uniform1f(getUniformLocation(p,"iFrame"),iFrame++);  
    uniform1f(gf(p,"iFrame"),iFrame++);  
    
    // Date
    // uniform1f(getUniformLocation(p,"iDate"), ~~f);
    uniform1f(gf(p,"iDate"),~~f);
    
    // Mouse coordinates
    // uniform4f(getUniformLocation(p,"iMouse"),iMouse[0],iMouse[1],iMouse[2],iMouse[3]);
    uniform4f(gf(p,"iMouse"),iMouse[0],iMouse[1],iMouse[2],iMouse[3]);
    
    // Viewport resolution
    // uniform2f(getUniformLocation(p,"iResolution"),640,360);
    uniform2f(gf(p,"iResolution"), 640, 360);
    
    // Draw
    // drawArrays(TRIANGLE_FAN,0,3);
    dr(6,0,3);
    
    // Next frame
    requestAnimationFrame(L);
  })();
}

// Mouse input:
// y: mouse down (0 / 1)
y=0;

// z: canvas size (1: half / 2: full screen)
z=1;

// Toggle y on mouse down / up
onmousedown=onmouseup=function(e){y^=1}

// Update iMouse on mouse move / click, according to z.
a.onmousemove=function(e){if(y)iMouse[0]=e.pageX*0.495*z,iMouse[1]=e.pageY}
a.onclick=function(e){iMouse[2]=e.pageX*0.495*z,iMouse[3]=e.pageY}

// On double click, toggle canvas size
a.ondblclick=function(e){z=3-z;a.style.width=c.style.width=z*49.5+'%'}

</script>
