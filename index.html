<!doctype html>
<meta charset=utf-8>
<body id=b style="height: 100vh; margin: 0px; box-sizing: border-box;">
<canvas id=a width=640 height=320>
<script>

d = document;
g = a.getContext('webgl');

/*

JS1K's shim gives the following vars for free:
- a: canvas element
- b: body
- d: document
- g: webgl context for the canvas.

*/

// GUI: canvas
a.style="width:100%;height:100vh";

// Canvas methods hashing:
// This loop creates tiny shortcuts for all the webgl context's methods/constants we need:
// createProgram => cP
// shaderSource => sS
// createShader => cS
// compileShader => ce
// attachShader => aS
// linkProgram => lo
// useProgram => ug
// bindBuffer => bf
// createBuffer => cB
// enableVertexAttribArray => eV
// vertexAttribPointer => vA
// bufferData => bD
// getUniformLocation => gf
// drawArrays => dr
// NO_ERROR => NO (value = 0)
// FRAGMENT_SHADER => FN (value: 35632)
// ELEMENT_ARRAY_BUFFER_BINDING => ET (value: 34965)
// We need to redefine the webgl context because adding the textarea in the DOM rewrote the canvas "a".

for(i in g){
  g[i[0] + i[6]] = g[i]
}
w = window
// Mouse coordinates
iMouse=[0,0,0,0];
// Use the WebGL context's scope for all the following code
with(g){
  // Define a new program
  // p=createProgram();
  p=cP();
  
  // Basic vertex shader
  // shaderSource(s=createShader(VERTEX_SHADER),"attribute vec2 p;void main(){gl_Position=vec4(p,0,1);}");
  sS(s=cS(35633),"attribute vec2 p;void main(){gl_Position=vec4(p,1,1);}");
  
  // Compile and attach it to the program
  // compileShader(s);
  ce(s);
  
  //attachShader(p,s);
  aS(p,s);
  
  // Main program
  // shaderSource(s=createShader(FRAGMENT_SHADER),'...');
  sS(s=cS(FN),`precision mediump float;uniform float iTime,iAspect;varying lowp vec4 fragCoord;uniform vec2 iResolution;uniform vec4 iMouse;void main(){vec2 v=gl_FragCoord.rg/iResolution.rg-.5;v.g*=iAspect;vec3 f=vec3(v,1.);float i=iTime,c=.5+iMouse.r/iResolution.r*2.,s=.8+iMouse.g/iResolution.g*2.;mat2 m=mat2(cos(c),sin(c),-sin(c),cos(c)),a=mat2(cos(s),sin(s),-sin(s),cos(s));f.rb*=m;f.rg*=a;vec3 n=vec3(1.,.5,.5);n+=vec3(i*2.,i,-2.);n.rb*=m;n.rg*=a;float g=.1,t=1.;vec3 l=vec3(0.);for(int u=0;u<20;u++){vec3 e=n+g*f*.5;e=abs(vec3(1.)-mod(e,vec3(2.)));float r,b=r=0.;for(int o=0;o<20;o++)e=abs(e)/dot(e,e)-.53,b+=abs(length(e)-r),r=length(e);float o=max(0.,.3-b*b*.001);if(u>6)t*=1.-o;l+=t;b*=b*b;l+=vec3(g,g*g,g*g*g*g)*b*.0015*t;t*=.73;g+=.1;}l=mix(vec3(length(l)),l,.85);gl_FragColor=vec4(l*.01,1.);}`);
  
  // Compile and attach it to the program
  // compileShader(s);
  ce(s);
  
  // DEBUGS
  if (!g.getShaderParameter(s, g.COMPILE_STATUS)) {
    g.getShaderInfoLog(s).trim().split("\n").forEach(ss =>
    console.warn("[shader] " + ss))
    throw new Error("Error while compiling shader")
  };

  // attachShader(p,s);
  aS(p,s);
  
  // Link and start the program
  //linkProgram(P);
  lo(p);
  
  //useProgram(p);
  ug(p);
  
  // Define a big triangle the canvas, containing the viewport
  // bindBuffer(g=ARRAY_BUFFER, createBuffer());
  bf(g=34962,cB());
  
  // enableVertexAttribArray(0);
  eV(0);
  
  // vertexAttribPointer(0, 2, BYTE, 0, 0, 0);
  vA(0,2,5120,0,0,0);
  
  // bufferData(g,new Int8Array([-3, 1, 1, -3, 1, 1]), STATIC_DRAW);
  bD(g,new Int8Array([-3,1,1,-3,1,1]),35044);
  
  // Reset frame counter
  iFrame=0;
  
  // Start time (in seconds)
  o = (new Date / 1e5);

  // Main loop
  (L=function(){
    // Current playback time (in 1/200 seconds)

    uniform1f(gf(p,"iTime"), (new Date / 1e5) - o);

    // Current sapect ration
    uniform1f(gf(p,"iAspect"), innerHeight / innerWidth);

    // Mouse coordinates
    // uniform4f(getUniformLocation(p,"iMouse"),iMouse[0],iMouse[1],iMouse[2],iMouse[3]);
    uniform4f(gf(p,"iMouse"),iMouse[0],iMouse[1],iMouse[2],iMouse[3]);
    
    // Viewport resolution
    // uniform2f(getUniformLocation(p,"iResolution"),640,360);
    uniform2f(gf(p,"iResolution"), 640, 320);

    // Draw
    // drawArrays(TRIANGLE_FAN,0,3);
    dr(6,0,3);
    
    // Next frame
    requestAnimationFrame(L);
  })();
}

// Mouse input:
// y: mouse down (0 / 1)
y=0;

// z: canvas size (1: half / 2: full screen)
z=1;

// Toggle y on mouse down / up
onmousedown=onmouseup=function(e){y^=1}

// Update iMouse on mouse move / click, according to z.
a.onmousemove=function(e){if(y)iMouse[0]=e.pageX*0.495*z,iMouse[1]=e.pageY}
a.onclick=function(e){iMouse[2]=e.pageX*0.495*z,iMouse[3]=e.pageY}

// On double click, toggle canvas size
a.ondblclick=function(e){z=3-z;a.style.width=c.style.width=z*49.5+'%'}

</script>
