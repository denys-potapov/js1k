<!doctype html>
<meta charset=utf-8>
<body id=b style="height: 100vh; margin: 0px; box-sizing: border-box;">
<canvas id=a width=640 height=640>
<script>

d = document;
g = a.getContext('webgl');

/*

JS1K's shim gives the following vars for free:
- a: canvas element
- b: body
- d: document
- g: webgl context for the canvas.

*/

// GUI: canvas
a.style="width:100%;height:100vh;float:left";

// Canvas methods hashing:
// This loop creates tiny shortcuts for all the webgl context's methods/constants we need:
// createProgram => cP
// shaderSource => sS
// createShader => cS
// compileShader => ce
// attachShader => aS
// linkProgram => lo
// useProgram => ug
// bindBuffer => bf
// createBuffer => cB
// enableVertexAttribArray => eV
// vertexAttribPointer => vA
// bufferData => bD
// getUniformLocation => gf
// drawArrays => dr
// NO_ERROR => NO (value = 0)
// FRAGMENT_SHADER => FN (value: 35632)
// ELEMENT_ARRAY_BUFFER_BINDING => ET (value: 34965)
// We need to redefine the webgl context because adding the textarea in the DOM rewrote the canvas "a".

for(i in g){
  g[i[0] + i[6]] = g[i];
}
// we use only one uniofrom
g.u = g.uniform1f;

// Mouse input:
// k: mouse down (0 / 1)
// x,y: mouse cords
x=y=k=0;

// Use the WebGL context's scope for all the following code
with(g){
  // Define a new program
  // p=createProgram();
  p=cP();
  
  // Basic vertex shader
  // shaderSource(s=createShader(VERTEX_SHADER),"attribute vec2 p;void main(){gl_Position=vec4(p,0,1);}");
  sS(s=cS(35633),"attribute vec2 p;void main(){gl_Position=vec4(p,1,1);}");
  
  // Compile and attach it to the program
  // compileShader(s);
  ce(s);
  
  //attachShader(p,s);
  aS(p,s);
  
  // Main program
  // shaderSource(s=createShader(FRAGMENT_SHADER),'...');
  sS(s=cS(FN),`precision mediump float;
uniform float t,a,x,y;

void main() {
  //get direction
  vec3 dir=vec3(gl_FragCoord.xy/640.-.5,1.);
  dir.y*=a;

  //mouse rotation
  float a1=.5+x/500.;
  float a2=.5+y/500.;
  mat2 rot1=mat2(cos(a1),sin(a1),-sin(a1),cos(a1));
  mat2 rot2=mat2(cos(a2),sin(a2),-sin(a2),cos(a2));
  dir.xz*=rot1;
  dir.xy*=rot2;
  vec3 from=vec3(1.,.5,0.5);
  from+=vec3(t*2.,t,-2.);
  from.xz*=rot1;
  from.xy*=rot2;
  
  //volumetric rendering
  float s=0.1,fade=1.;
  vec3 v=vec3(0.);

  // for (int r=0; r<volsteps; r++) {
  // #define volsteps 20
  for (int r=0; r<20; r++) {
    vec3 p=from+s*dir*.5;
    p = abs(vec3(1.)-mod(p,vec3(2.))); // tiling fold
    float pa,a=pa=0.;
    // for (int i=0; i<iterations; i++) { 
    // #define iterations 17
    for (int r=0; r<20; r++) { 
      p=abs(p)/dot(p,p)-0.53; // the magic formula #define formuparam 0.53
      a+=abs(length(p)-pa); // absolute sum of average change
      pa=length(p);
    }

    if (r>6) fade*=1.-max(0.,.3-a*a*.001); // dark matter, don't render near
    //v+=vec3(dm,dm*.5,0.);

    // v+=vec3(s,s*s,s*s*s*s)*a*brightness*fade;
    // #define brightness 0.0015

    v+=fade + vec3(s,s*s,s*s*s*s)*a*a*a*.0015*fade; // coloring based on distance
    fade*=.73; // distance fading #define distfading 0.730
    s+=0.1; // #define stepsize 0.1
  }
  // #define saturation 0.850
  v=mix(vec3(length(v)),v,.85); //color adjust
  gl_FragColor = vec4(v*.01,1.); 
}`);
  
  // Compile and attach it to the program
  // compileShader(s);
  ce(s);
  
  // DEBUGS
  if (!g.getShaderParameter(s, g.COMPILE_STATUS)) {
    g.getShaderInfoLog(s).trim().split("\n").forEach(ss =>
    console.warn("[shader] " + ss))
    throw new Error("Error while compiling shader")
  };

  // attachShader(p,s);
  aS(p,s);
  
  // Link and start the program
  //linkProgram(P);
  lo(p);
  
  //useProgram(p);
  ug(p);
  
  // Define a big triangle the canvas, containing the viewport
  // bindBuffer(g=ARRAY_BUFFER, createBuffer());
  bf(g=34962,cB());
  
  // enableVertexAttribArray(0);
  eV(0);
  
  // vertexAttribPointer(0, 2, BYTE, 0, 0, 0);
  vA(0,2,5120,0,0,0);
  
  // bufferData(g,new Int8Array([-3, 1, 1, -3, 1, 1]), STATIC_DRAW);
  bD(g,new Int8Array([-3,1,1,-3,1,1]),35044);

  // Start time (in seconds)
  o = (new Date / 1e5);

  // Main loop
  (L=function(e){
    // Current playback time (in 1/200 seconds)
    u(gf(p,"t"), (new Date / 1e5) - o);

    // Current sapect ration
    u(gf(p,"a"), innerHeight / innerWidth);

    // Mouse coordinates
    u(gf(p,"x"), x);
    u(gf(p,"y"), y);

    // Draw
    // drawArrays(TRIANGLE_FAN,0,3);
    dr(6,0,3);
    
    // Next frame
    requestAnimationFrame(L);
  })();
}


// Toggle d on mouse down / up
onmousedown=onmouseup=function(e){k^=1}

// Update iMouse on mouse move / click, according to z.
onmousemove=function(e){if(k)x=e.pageX,y=e.pageY}

</script>
